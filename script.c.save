
#include "common.h"
#include "config.h"
#include "jsapi.h"
#include "jsatom.h"
#include "jsstr.h"
#include "jspubtd.h"

#define dlevel 6

#define TYPEOF(cx,v)    (JSVAL_IS_NULL(v) ? JSTYPE_NULL : JS_TypeOfValue(cx,v))

char *jstypestr(JSContext *cx, jsval vp) {
	return (char *)JS_GetTypeName(cx, JS_TypeOfValue(cx, vp));
}

jsval typetojsval(JSContext *cx, enum DATA_TYPE type, void *dest, int len) {
	jsval val;

	dprintf(1,"type: %d(%s), dest: %p, len: %d\n", type, typestr(type), dest, len);

	switch (type) {
	case DATA_TYPE_BYTE:
		val = INT_TO_JSVAL(*((uint8_t *)dest));
		break;
	case DATA_TYPE_SHORT:
		val = INT_TO_JSVAL(*((short *)dest));
		break;
	case DATA_TYPE_BOOL:
		val = BOOLEAN_TO_JSVAL(*((int *)dest));
		break;
	case DATA_TYPE_INT:
		val = INT_TO_JSVAL(*((int *)dest));
		break;
	case DATA_TYPE_LONG:
		val = INT_TO_JSVAL(*((long *)dest));
		break;
	case DATA_TYPE_FLOAT:
		JS_NewDoubleValue(cx, *((float *)dest), &val);
		break;
#if 0
	case JSTYPE_VOID:
		dprintf(1,"void!\n");
		break;
	case JSTYPE_OBJECT:
		dprintf(1,"obj!\n");
		break;
	case JSTYPE_FUNCTION:
		dprintf(1,"func!\n");
		break;
	case JSTYPE_STRING:
		str = (char *)js_GetStringBytes(cx, JSVAL_TO_STRING(val));
		strcpy(${prefix}${v},JS_GetStringBytes(JSVAL_TO_STRING(*vp)));
		conv_type(dtype,dest,dlen,DATA_TYPE_STRING,str,strlen(str));
		*rval = STRING_TO_JSVAL(JS_NewStringCopyZ(cx,${prefix}${v}));
		break;
	case JSTYPE_NUMBER:
		if (JSVAL_IS_INT(val)) {
			i = JSVAL_TO_INT(val);
			conv_type(dtype,dest,dlen,DATA_TYPE_INT,&i,0);
		} else if (JSVAL_IS_DOUBLE(val)) {
			d = *JSVAL_TO_DOUBLE(val);
			conv_type(dtype,dest,dlen,DATA_TYPE_DOUBLE,&d,0);
		} else {
			dprintf(1,"unknown number type!\n");
		}
		break;
	case JSTYPE_BOOLEAN:
		i = JSVAL_TO_BOOLEAN(val);
		conv_type(dtype,dest,dlen,DATA_TYPE_BOOL,&i,0);
		break;
	case JSTYPE_NULL:
		str = (char *)JS_TYPE_STR(jstype);
		conv_type(dtype,dest,dlen,DATA_TYPE_STRING,str,strlen(str));
		break;
	case JSTYPE_XML:
		dprintf(1,"xml!\n");
		break;
#endif
	default:
		val = JSVAL_NULL;
		dprintf(1,"unhandled type!\n");
		break;
	}
	return val;
}

void jsvaltotype(enum DATA_TYPE dtype, void *dest, int dlen, JSContext *cx, jsval val) {
	int jstype;
	int i;
	char *str;
	double d;

	jstype = TYPEOF(cx,val);
	dprintf(1,"jstype: %d(%s), dtype: %d(%s), dest: %p, dlen: %d\n", jstype, jstypestr(cx,val), dtype, typestr(dtype), dest, dlen);

	switch (jstype) {
	case JSTYPE_VOID:
		dprintf(1,"void!\n");
		break;
	case JSTYPE_OBJECT:
		dprintf(1,"obj!\n");
		break;
	case JSTYPE_FUNCTION:
		dprintf(1,"func!\n");
		break;
	case JSTYPE_STRING:
		str = (char *)js_GetStringBytes(cx, JSVAL_TO_STRING(val));
		conv_type(dtype,dest,dlen,DATA_TYPE_STRING,str,strlen(str));
		break;
	case JSTYPE_NUMBER:
		if (JSVAL_IS_INT(val)) {
			i = JSVAL_TO_INT(val);
			conv_type(dtype,dest,dlen,DATA_TYPE_INT,&i,0);
		} else if (JSVAL_IS_DOUBLE(val)) {
			d = *JSVAL_TO_DOUBLE(val);
			conv_type(dtype,dest,dlen,DATA_TYPE_DOUBLE,&d,0);
		} else {
			dprintf(1,"unknown number type!\n");
		}
		break;
	case JSTYPE_BOOLEAN:
		i = JSVAL_TO_BOOLEAN(val);
		conv_type(dtype,dest,dlen,DATA_TYPE_BOOL,&i,0);
		break;
	case JSTYPE_NULL:
		str = (char *)JS_TYPE_STR(jstype);
		conv_type(dtype,dest,dlen,DATA_TYPE_STRING,str,strlen(str));
		break;
	case JSTYPE_XML:
		dprintf(1,"xml!\n");
		break;
	default:
		dprintf(1,"unknown type: %d\n",jstype);
		break;
	}
}

JSPropertySpec *configtoprops(config_t *cp, char *name, JSPropertySpec *add) {
	JSPropertySpec *props,*pp,*app;
	config_section_t *section;
	config_property_t *p;
	int count;

	section = config_get_section(cp,name);
	if (!section) {
		sprintf(cp->errmsg,"unable to find config section: %s\n", name);
		return 0;
	}

	/* Get total count */
	count = list_count(section->items);
	if (add) for(app = add; app->name; app++) count++;
	/* Add 1 for termination */
	count++;
	dprintf(1,"count: %d\n", count);
	props = calloc(count * sizeof(JSPropertySpec),1);
	if (!props) {
		sprintf(cp->errmsg,"calloc props(%d): %s\n", count, strerror(errno));
		return 0;
	}

	dprintf(1,"adding config...\n");
	pp = props;
	list_reset(section->items);
	while((p = list_get_next(section->items)) != 0) {
		pp->name = p->name;
		pp->tinyid = p->id;
		pp->flags = JSPROP_ENUMERATE;
		if (p->flags & CONFIG_FLAG_READONLY) pp->flags |= JSPROP_READONLY;
		pp++;
	}

	/* Now add the addl props, if any */
	if (add) for(app = add; app->name; app++) *pp++ = *app;

	dprintf(1,"dump:\n");
	for(pp = props; pp->name; pp++) 
		dprintf(1,"prop: name: %s, id: %d, flags: %02x\n", pp->name, pp->tinyid, pp->flags);

	config_build_propmap(cp);

	return props;
}

#if 0
int Delay(int n) {
#ifdef WINDOWS
	double a;
	int l,h;

	dprintf(1,"n: %d\n",n);
	a = n * 0.1;
	h = (int)(a / 2);
	l = n - h;
	h += n;
//	dprintf(1,"a: %f, l: %d, h: %d", a, l, h);
	return (SleepEx(Rand(l,h),1) == WAIT_IO_COMPLETION);
#else
	return sleep(n);
#endif
}

static int jsDelay(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval) {

	if (stop) return JS_FALSE;
	return (Delay(JSVAL_TO_INT(argv[0])) ? JS_FALSE : JS_TRUE);
}

static int jsprint(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval) {
	char msg[1024];
	register u_int i;

	msg[0] = 0;
	for(i = 0; i < argc; i++)	{
//		if (JSVAL_IS_INT(argv[i]) || JSVAL_IS_DOUBLE(argv[i]) || JSVAL_IS_STRING(argv[i]) || JSVAL_IS_BOOLEAN(argv[i]))
			strcat(msg,JS_GetStringBytes(JSVAL_TO_STRING(argv[i])));
	}
	printf("\n*****\n%s\n\n",msg);
	return JS_TRUE;
}

static JSBool Print(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval) {
    uintN i;
    JSString *str;
    char *bytes;

    for (i = 0; i < argc; i++) {
        str = JS_ValueToString(cx, argv[i]);
        if (!str)
            return JS_FALSE;
        bytes = JS_EncodeString(cx, str);
        if (!bytes)
            return JS_FALSE;
        printf("%s%s", i ? " " : "", bytes);
        JS_free(cx, bytes);
    }

	printf("\n");

    return JS_TRUE;
}

static int jserror(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval) {
	char msg[1024];
	register u_int i;

	if (stop) return JS_FALSE;
//	dprintf(1,"jserror");

	msg[0] = 0;
	for(i = 0; i < argc; i++)	{
		if (JSVAL_IS_STRING(argv[i]))
			strcat(msg,JS_GetStringBytes(JSVAL_TO_STRING(argv[i])));
	}
	JS_ReportError(cx,msg);
	return JS_TRUE;
}

static int jsExit(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval) {
	int status;

	if (stop) return JS_FALSE;
	dprintf(1,"jsExit");

	status = (argc ? JSVAL_TO_INT(argv[0]) : 0);

	dprintf(1,"status: %d\n", status);
	exit(status);
}

static int jsTime(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval) {
	time_t t;

	if (stop) return JS_FALSE;
//	dprintf(1,"jsTime");

	time(&t);
	t &= 0x0FFFFFFF;
//	dprintf(1,"jsTime: time: %d", t);
	*rval = INT_TO_JSVAL(t);
	return JS_TRUE;
}

static int rand_primed = 0;

static int jsRand(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval) {
	int low,high;

	if (!rand_primed) srand((unsigned int)time(NULL));

	if (stop) return JS_FALSE;
	if (argc < 2)
		*rval = INT_TO_JSVAL(0);
	else {
		low = JSVAL_TO_INT(argv[0]);
		high = JSVAL_TO_INT(argv[1]);
#ifdef WINDOWS
		*rval = INT_TO_JSVAL(Rand(low,high));
#else
		*rval = (low + rand() / (RAND_MAX / (high - low + 1) + 1));
#endif
	}
	return JS_TRUE;
}

#if 0
static int jsinclude(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval) {
	char *name;
	jsval status;

	if (stop) return JS_FALSE;
	dprintf(1,"argc: %d, argv: %p\n",argc,argv);

	dprintf(1,"argc: %d", argc);
	if (!argc) return JS_TRUE;

	name = JS_GetStringBytes(JS_ValueToString(cx, argv[0]));
	dprintf(1,"name: %s", name);

	status = script_include(cx, obj, name);
	return JS_TRUE;
}
#endif

static int jsRun(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval) {
	char *name;

	if (stop) return JS_FALSE;

	name = JS_GetStringBytes(JS_ValueToString(cx, argv[0]));
	*rval = INT_TO_JSVAL(script_run(cx,obj,name,argc-1,&argv[1]));

	return JS_TRUE;
}

#if 0
static int jsme(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval) {
	JSStackFrame *fp;
//	JSBool ok;

	/* Get the currently executing script's name. */
	fp = JS_GetScriptedCaller(cx, NULL);
	if (!fp || !fp->script || !fp->script->filename) {
		dprintf(1,"unable to get current script!\n");
	}
	dprintf(1,"filename: %s\n", fp->script->filename);
	return JS_TRUE;
}
#endif

JSClass global_class;

#if 0
JSClass global_class = {
    "global", JSCLASS_NEW_RESOLVE | JSCLASS_GLOBAL_FLAGS,
    JS_PropertyStub,  JS_PropertyStub,
    JS_PropertyStub,  JS_PropertyStub,
    global_enumerate, (JSResolveOp) global_resolve,
    JS_ConvertStub,   JS_FinalizeStub,
    JSCLASS_NO_OPTIONAL_MEMBERS
};
#endif

#if 0
/* core script functions */
static JSClass global_class = {
	"global", 0,
	JS_PropertyStub, JS_PropertyStub, JS_PropertyStub, JS_PropertyStub,
	JS_EnumerateStub, JS_ResolveStub, JS_ConvertStub, JS_FinalizeStub,
	JSCLASS_NO_OPTIONAL_MEMBERS
};
#endif

	JSFunctionSpec core_functions[] = {
		{ "rand",				jsRand,			2 },
		{ "exit",				jsExit,			0 },
		{ "sleep",				jsDelay,		1 },
		{ "error",				jserror,		1 },
		{ "time",				jsTime,			0 },
		{0}
	};

JSObject *CreateGlobalObject(JSContext *cx) {
	JSObject *obj;

	dprintf(1,"Adding core objects...\n");

	obj = JS_NewObject(cx, &global_class, 0, 0);
	if(!obj) return 0;
	if(!JS_InitStandardClasses(cx, obj)) return 0;
	if(!JS_DefineFunctions(cx, obj, core_functions)) return 0;
	return obj;
}

void script_error(JSContext *cx, const char *message, JSErrorReport *report) {
	if (message && report) {
		log_error("%s(%d): %s", report->filename, report->lineno, message);
	} else {
		log_error("%s\n",message);
	}
	return;
}

#if SCRIPT_LOAD
static char *_loadfile(char *name, int size) {
	char buf[4096];
	char *data;
	FILE *fp;
	int bytes,fd;

	dprintf(dlevel,"_loadfile: name: %s, size: %d", name, size);
	if (!size) return 0;
	data = malloc(size);
	if (!data) {
		log_error("_loadfile: malloc(%d)\n", size);
		return 0;
	}
	fd = open(name,O_RDONLY);
	if (fd < 0) {
		log_syserror("_loadfile: open(%s)",name);
		goto _loadfile_error;
	}
	bytes = read(fd,data,size);
	dprintf(1,"bytes: %d\n", bytes);
	if (bytes != size) {
		log_syserror("_loadfile: bytes(%d) != size(%d)",bytes,size);
		goto _loadfile_error;
	}
	close(fd);

	dprintf(dlevel,"_loadfile: returning data: %p", data);
	return data;

_loadfile_error:
	free(data);
	return 0;
}

#include "jsxdrapi.h"

//extern JSBool js_XDRScript(JSXDRState *xdr, JSScript **scriptp, JSBool *hasMagic);

int _script_freeze(JSContext *cx, char *name, JSScript *script, long t) {
    JSXDRState *xdr;
    JSBool ok, hasMagic;
    uint32 len;
    void *buf;
	FILE *fp;
	os_utimbuf_t ut;
	int error;

	dprintf(dlevel,"_script_freeze: name: %s, script: %p, t: %x", name, script, t);

	error = 1;

	// Create a new XDR
	xdr = JS_XDRNewMem(cx, JSXDR_ENCODE);
	if (!xdr) return 1;

	// Convert from script
	ok = js_XDRScript(xdr, &script, &hasMagic);
	if (!ok) {
		dprintf(dlevel,"_script_freeze: XDRScript returned an error!");
		goto done;
	}
	if (!hasMagic) {
		dprintf(dlevel,"_script_freeze: hasMagic == 0!");
		goto done;
	}

	// Get the data
	buf = JS_XDRMemGetData(xdr, &len);
	if (!buf) {
		dprintf(dlevel,"_script_freeze: unable to get XDR data!");
		goto done;
	}

	// Write the data
	fp = fopen(name,"wb+");
	if (!fp) {
		log_syserror("fopen(%s,w+)", name);
		goto done;
	}
	dprintf(dlevel,"writing %d chars...",len);
	fwrite(buf,len,1,fp);
	fclose(fp);

	// Set the time
	ut.actime = t;
	ut.modtime = t;
	os_utime(name,&ut);

	error = 0;
done:
	JS_XDRDestroy(xdr);
	return error;
}

extern void js_CallNewScriptHook(JSContext *cx, JSScript *script, JSFunction *fun);

JSScript *_script_thaw(JSContext *cx, char *name, int len) {
    JSXDRState *xdr;
	JSScript *script;
    JSBool ok, hasMagic;
	jschar *buf;
	FILE *fp;

	dprintf(dlevel,"name: %s, len: %d", name, len);

	// Alloc buf
	buf = malloc(len);
	if (!buf) return 0;

	// Read in XDR data
	fp = fopen(name,"rb");
	if (!fp) {
		dprintf(dlevel,"fopen(%s,rb)",name);
		free(buf);
		return 0;
	}
	fread(buf,len,1,fp);
	fclose(fp);

	// Create decode XDR
    xdr = JS_XDRNewMem(cx, JSXDR_DECODE);
    if (!xdr) {
		free(buf);
		return 0;
	}

	// Set the data
    JS_XDRMemSetData(xdr, buf, len);

	// Convert
    ok = js_XDRScript(xdr, &script, &hasMagic);
    if (!ok) {
		dprintf(dlevel,"_script_thaw: XDRScript returned an error!");
		script = 0;
		goto done;
	}
    if (!hasMagic) {
		dprintf(dlevel,"_script_thaw: hasMagic == 0!");
		script = 0;
		goto done;
	}

	// Call scripthook
    js_CallNewScriptHook(cx, script, NULL);

done:
	JS_XDRDestroy(xdr);
	return script;
}

JSScript *script_load(JSContext *cx, JSObject *obj, char *name) {
	char cpath[1024], *data, *p;
	struct stat csb,sb;
	JSScript *script;

	dprintf(dlevel,"name: %s", name);

	// Can we stat the source?
	if (stat(name, &sb) < 0) {
		char message[1024];
#ifdef WINDOWS
		char str[256];
		GetLastErrorText(str,sizeof(str);
#else
		char *str = strerror(errno);
#endif
		sprintf(message,"unable to load script \'%s\': %s", name, str);
		JS_ReportError(cx, message);
		return 0;
	}

	// Is there a compiled version?
	strcpy(cpath,name);
	p = strrchr(cpath,'.');
	if (p) *p = 0;
	strcat(cpath,".jsc");
	dprintf(dlevel,"cpath: %s", cpath);

	// Compiled script exists and is same as source?
	script = 0;
	if (stat(cpath,&csb) == 0 && csb.st_mtime == sb.st_mtime) {
		// Thaw script
		script = _script_thaw(cx,cpath,csb.st_size);
	}

	// Always fall back to loading from source
	if (!script) {
		// Load source
		data = _loadfile(name,sb.st_size);
		if (!data) return 0;

		// Compile script
		script = JS_CompileScript(cx,obj,data,strlen(data),name,1);
		free(data);

		/* Compile it */
		_script_freeze(cx,cpath,script,sb.st_mtime);

	}

	dprintf(dlevel,"script_load: returning script: %p", script);
	return script;
}
#endif

JSScript *get_script(JSContext *cx, JSObject *obj, char *name) {
#if SCRIPT_LOAD
	return script_load(cx, obj, name);
#else
	return JS_CompileFile(cx, obj, name);
#endif
}

static int script_abort(JSContext *cx, JSScript *script) {
//	dprintf(dlevel,"script_abort: stop: %d", stop);
//	return (stop ? JS_FALSE : JS_TRUE);
	return JS_FALSE;
}


static int _script_exec(JSContext *cx, JSObject *obj, char *name, char *func, int argc, jsval *argv) {
	JSScript *script;
	int ok,status;
	jsval rval;

	dprintf(dlevel,"cx: %p, obj: %p, name: %s, func: %s, argc: %d, argv: %p", cx, obj, name, func, argc, argv);
	if (!name) return 1;

	script = get_script(cx,obj,name);
	dprintf(1,"script: %p\n", script);
	status = -1;
	if (script) {
		ok = JS_ExecuteScript(cx, obj, script, &rval);
		dprintf(1,"ok: %d\n", ok);
		ok = 1;
		if (ok) {
			if (func) {
				ok = JS_GetProperty(cx, obj, func, &rval);
				dprintf(1,"ok: %d\n", ok);
				if (ok) {
					dprintf(1,"isvoid: %d\n", JSVAL_IS_VOID(rval));
					if (JSVAL_IS_VOID(rval)) {
						dprintf(1,"function not found!\n");
					} else {
					dprintf(dlevel,"calling %s %s\n", name, func);
					if (JS_CallFunctionName(cx, obj, func, argc, argv, &rval) == JS_FALSE) {
						dprintf(dlevel,"error calling function!");
						status = -1;
					} else {
						status = JSVAL_TO_INT(rval);
					}
					}
				} else {
					dprintf(1,"unable to get property!\n");
				}
			}
		} else {
			dprintf(1,"error executing script!\n");
		}
		JS_DestroyScript(cx, script);
	} else {
		log_error("_script_exec: %s: failed to compile!\n", name);
	}
	dprintf(1,"status: %d\n", status);

	dprintf(dlevel,"_script_exec: %s: status: %d", name, status);
	return status;
}

#if 0
        jsval argv[5];
        argv[0] = OBJECT_TO_JSVAL(screenArrayBuffer);
        argv[1] = INT_TO_JSVAL(WIDTH);
        argv[2] = INT_TO_JSVAL(HEIGHT);
        argv[3] = INT_TO_JSVAL(screen->pitch);
        argv[4] = INT_TO_JSVAL(BPP);
        JSBool ok = JS_CallFunctionName(cx, global, "paint", 5, argv, &rval);
#endif

int script_include(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval) {
    uintN i;
    JSString *str;
    const char *filename;
    JSScript *script;
    JSBool ok;
    jsval result;
    uint32 oldopts;

    for (i = 0; i < argc; i++) {
        str = JS_ValueToString(cx, argv[i]);
        if (!str) return JS_FALSE;
        argv[i] = STRING_TO_JSVAL(str);
        filename = JS_GetStringBytes(str);
	dprintf(1,"filename: %s\n", filename);
        errno = 0;
        oldopts = JS_GetOptions(cx);
        JS_SetOptions(cx, oldopts | JSOPTION_COMPILE_N_GO);
        script = JS_CompileFile(cx, obj, filename);
	dprintf(1,"script: %p\n", script);
        if (!script) {
            ok = JS_FALSE;
        } else {
//            ok = !compileOnly ? JS_ExecuteScript(cx, obj, script, &result) : JS_TRUE;
		ok = JS_ExecuteScript(cx, obj, script, &result);
		dprintf(1,"ok: %d\n", ok);
            JS_DestroyScript(cx, script);
        }
        JS_SetOptions(cx, oldopts);
        if (!ok) return JS_FALSE;
    }

    return JS_TRUE;
}

#if 0
// exec a script in the current cx and thread
int script_include(JSContext *cx, JSObject *obj, char *name) {
#if 0
	JSContext *icx;
	jsval rval;
	int status;
	JSBool ok;
	JSScript *script;
	JSObject *newobj;
#endif

        JSContext *icx;
        int status;

        dprintf(1,"exec'ing...");
        status = _script_exec(cx,obj,name,0,0,0);

        return status;

#if 0
	script = get_script(cx, obj, name);
	newobj = JS_NewScriptObject(cx, script);
	ok = JS_ExecuteScript(cx, newobj, script, &rval);
	dprintf(1,"ok: %d\n", ok);
	dprintf(1,"rval: %d\n", rval);
	status = (ok ? 0 : -1);
#if 0
#if 1
	icx = JS_NewContext(cx->runtime, STACK_SIZE);
	if (!icx) return 1;
	JS_SetErrorReporter(icx, script_error);
	JS_SetBranchCallback(icx, script_abort);
//	status = _script_exec(icx,obj,name,0,0,0);
	script = get_script(icx, obj, name);
	ok = JS_ExecuteScript(icx, obj, script, &rval);
	dprintf(1,"ok: %d\n", ok);
	status = (ok ? 0 : 1);
	JS_DestroyContext(icx);
#else
	script = get_script(cx, obj, name);
	ok = JS_ExecuteScript(cx, obj, script, &rval);
	dprintf(1,"ok: %d\n", ok);
	status = (ok ? 0 : 1);
#endif
#endif
#endif

	dprintf(1,"status: %d\n", status);
	//return (status == 0 ? JS_TRUE : JS_FALSE);
	return JS_TRUE;
}
#endif

// exec a script with a new cx in the current thread
int script_run(JSContext *cx, JSObject *obj, char *name, int argc, jsval *argv) {
	JSObject *newobj;
	JSScript *script;
	int status;
	JSBool ok;
	jsval rval;

	dprintf(dlevel,"name: %s", name);

	script = get_script(cx, obj, name);
	newobj = JS_NewScriptObject(cx, script);
	ok = JS_ExecuteScript(cx, newobj, script, &rval);
	dprintf(1,"ok: %d\n", ok);
	ok = JS_CallFunctionName(cx, newobj, "main", 0, 0, &rval);
	dprintf(1,"ok: %d\n", ok);
	dprintf(1,"rval: %d\n", rval);
	status = (ok ? 0 : -1);

#if 0
	JSContext *rcx;
	rcx = JS_NewContext(cx->runtime, STACK_SIZE);
	dprintf(1,"rcx: %p\n", rcx);
	if (!rcx) return 1;
	JS_SetErrorReporter(rcx, script_error);
	JS_SetBranchCallback(rcx, script_abort);

	dprintf(dlevel,"script_run: exec'ing...");
	status = _script_exec(rcx,obj,name,"main",argc,argv);
	if (stop) JS_GC(rcx);
	JS_DestroyContext(rcx);
#endif

	dprintf(1,"status: %d\n", status);
	return status;
}

struct start_info {
	JSRuntime *rt;
	char name[256];
	char func[64];
	int argc;
	jsval *argv;
};

static void *_script_start(void *ctx) {
	struct start_info *info = ctx;
	JSContext *cx;
	JSObject *obj;
	int status;

	dprintf(dlevel,"info: %p",info);
	if (!info) return 0;
	dprintf(dlevel,"info: rt: %p, name: %s",info->rt, info->name);

	cx = JS_NewContext(info->rt, STACK_SIZE);
	if (!cx) goto done;
//	JS_SetContextCallback(info->rt, ContextCallback);
	JS_SetErrorReporter(cx, script_error);
//	JS_SetBranchCallback(cx, script_abort);
	obj = CreateGlobalObject(cx);
	if (!obj) goto done;

	// Exec the script
	status = _script_exec(cx, JS_GetGlobalObject(cx), info->name, (strlen(info->func) ? info->func : 0), info->argc, info->argv);
//	status = _script_exec(cx, obj, info->name, (strlen(info->func) ? info->func : 0), info->argc, info->argv);
	dprintf(1,"status: %d\n",status);
	JS_GC(cx);
	JS_DestroyContext(cx);

done:
	free(info);
	dprintf(dlevel,"_script_start: status: %d",status);

//	thread_end(status == JS_TRUE ? 0 : 1);
#if 0
	{
		pthread_t tid;
		void *sptr;
		tid = pthread_self();
		if (tid) {
			pthread_cancel(tid);
			pthread_join(tid,&sptr);
		}
	}
#endif
	return 0;
}

// exec a script with a new cx and new thread
int script_start(JSRuntime *rt, char *name) {
	struct start_info *info;
//	pthread_t tid;

	if (!name) return 1;

	info = calloc(sizeof(*info),1);
	if (!info) return 1;
	info->rt = rt;
	strcpy(info->func,"main");
	strcpy(info->name,name);
	dprintf(dlevel,"info: rt: %p, name: %s",info->rt, info->name);

//	thread_start("script",_script_start,ptr,THREAD_PRIORITY_NORMAL);
//	pthread_create(&tid,NULL,_script_start,info);
	_script_start(info);
	dprintf(dlevel,"done!");
	return 0;
}

void script_stop(void) {

	dprintf(dlevel,"script_stop");

	// Set stop flag
//	stop = 1;

	// Let functions abort
//	Delay(100);

	// Kill thread(s)
//	thread_stop("script");
}

static JSBool Load(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
{
    uintN i;
    JSString *str;
    const char *filename;
    JSScript *script;
    JSBool ok;
    jsval result;
    uint32 oldopts;

    for (i = 0; i < argc; i++) {
        str = JS_ValueToString(cx, argv[i]);
        if (!str)
            return JS_FALSE;
        argv[i] = STRING_TO_JSVAL(str);
        filename = JS_GetStringBytes(str);
        errno = 0;
        oldopts = JS_GetOptions(cx);
        JS_SetOptions(cx, oldopts | JSOPTION_COMPILE_N_GO);
        script = JS_CompileFile(cx, obj, filename);
        if (!script) {
            ok = JS_FALSE;
        } else {
		ok = JS_ExecuteScript(cx, obj, script, &result);
            JS_DestroyScript(cx, script);
        }
        JS_SetOptions(cx, oldopts);
        if (!ok) return JS_FALSE;
    }

    return JS_TRUE;
}

#if 0
static JSBool
Print(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
{
    uintN i;
    JSString *str;
    char *bytes;

    for (i = 0; i < argc; i++) {
        str = JS_ValueToString(cx, argv[i]);
        if (!str)
            return JS_FALSE;
        bytes = JS_EncodeString(cx, str);
        if (!bytes)
            return JS_FALSE;
        fprintf(stdout, "%s%s", i ? " " : "", bytes);
        JS_free(cx, bytes);
    }

    fputc('\n', stdout);
    fflush(stdout);

    return JS_TRUE;
}
#endif

static JSFunctionSpec jscore_functions[] = {
	JS_FS_END
};

#if 0
int jscore_addfuncs(JSContext *cx, JSObject *obj) {
	JSBool ok;

	ok = JS_DefineFunctions(cx, glob, jscore_functions);
	dprintf(1,"ok: %d\n", ok);
	return (ok ? 0 : 1);
}
#endif
#endif
