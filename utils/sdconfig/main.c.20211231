
/*
Copyright (c) 2021, Stephen P. Shoecraft
All rights reserved.

This source code is licensed under the BSD-style license found in the
LICENSE file in the root directory of this source tree.
*/

#include "client.h"
#include "uuid.h"

#define TESTING 0

struct client_agent_info {
	char id[SOLARD_ID_LEN];
	char target[SOLARD_ROLE_LEN+SOLARD_NAME_LEN];
	int status;
	char errmsg[1024];
	json_value_t *info;
	list funcs;
};
typedef struct client_agent_info client_agent_info_t;

static int agent_request(solard_client_t *s, client_agent_info_t *ap, char *message, int timeout) {
	char topic[SOLARD_TOPIC_LEN];
	solard_message_t *msg;
	json_value_t *v;
	int status,found,count;
	char *errmsg;

	dprintf(1,"===> message:\n%s\n", message);

	sprintf(topic,"%s/%s",SOLARD_TOPIC_ROOT,ap->id);
	dprintf(1,"topic: %s\n",topic);
	mqtt_pub(s->m,topic,message,1,0);

#if 0
	count = 0;
	while(1) {
		/* Wait for message from that ID */
		msg = solard_message_wait_id(s->mq, ap->id, 1);
		dprintf(1,"msg: %p\n", msg);
		if (!msg) {
			log_error("timeout waiting for reply from %s\n", ap->target);
			return 1;
		}
		solard_message_dump(msg,1);
		v = json_parse(msg->data);
		str = json_object_get_string(json_value_get_object(v),"status");
		if (str) {
					if (v && json_value_get_type(v) == JSON_TYPE_OBJECT) {
						status = json_object_get_number(json_value_get_object(v),"status");
						errmsg = json_object_get_string(json_value_get_object(v),"message");
						dprintf(1,"status: %d, errmsg: %s\n", status, errmsg);
						found = 1;
						break;
					}
		count++;
	}
#else
	/* If timeout, wait for a response */
	status = 1;
	errmsg = "error";
	found = 0;
	if (timeout > 0) {
		while(timeout--) {
			dprintf(1,"count: %d\n", list_count(s->mq));
			list_reset(s->mq);
			while((msg = list_get_next(s->mq)) != 0) {
				/* If the message role is my ID, its a reply */
				solard_message_dump(msg,1);
				dprintf(1,"msg->id: %s, clientid: %s\n", msg->id, s->mqtt_config.clientid);
				if (strcmp(msg->id,s->mqtt_config.clientid) == 0) {
					dprintf(1,"Got response:\n");
					v = json_parse(msg->data);
					dprintf(1,"v: %p\n", v);
					if (v && json_value_get_type(v) == JSON_TYPE_OBJECT) {
						status = json_object_get_number(json_value_get_object(v),"status");
						errmsg = json_object_get_string(json_value_get_object(v),"message");
						dprintf(1,"status: %d, errmsg: %s\n", status, errmsg);
						found = 1;
						break;
					}
				}
				list_delete(s->mq,msg);
			}
			if (!found) sleep(1);
			else break;
		}
	}
	if (found) {
		printf("%s: %s\n", ap->target, errmsg);
	} else {
		printf("%s: no reply\n", ap->target);
	}
#endif
	return 0;
}

static json_value_t *catargs(int argc,char *argv[],config_function_t *f) {
	json_object_t *o;
	json_array_t *a;
	int i;

	/* nargs = 1: Object with function name and array of arguments */
	/* { "func": [ "arg", "argn", ... ] } */
	/* nargs = 2: Object with function name and array of objects with key:value pairs */
	/* { "func": [ { "key": "value" }, { "keyn": "valuen" }, ... ] } */
	/* nargs > 2: Object with function name and array of argument arrays */
	/* { "func": [ [ "arg", "argn", ... ], [ "arg", "argn" ], ... ] } */
	o = json_create_object();
	a = json_create_array();
	if (f->nargs == 1) {
		for(i=0; i < argc; i++) json_array_add_string(a,argv[i]);
	} else if (f->nargs == 2) {
		json_object_t *oo;

		i = 0;
		while(i < argc) {
			oo = json_create_object();
			json_object_set_string(oo,argv[i],argv[i+1]);
			json_array_add_object(a,oo);
			i += 2;
		}
	} else if (f->nargs > 2) {
		printf("notimpl\n");
	}
	json_object_set_array(o,f->name,a);
	return json_object_get_value(o);
#if 0

	while(i < argc) {
		dprintf(1,"i: %d, argc: %d\n", i, argc);
		aa = json_create_array();
		for(j=0; j < f->nargs; j++) json_array_add_string(aa,argv[i++]);
		json_object_set_array(o,f->name,aa);
		json_array_add_object(a,o);
		if (!f->nargs) break;
	}
	return json_array_get_value(a);
		for(i=2; i < argc; i++) {
			json_array_add_string(a,argv[i]);
		}
	if (act == 1) {
		for(i=2; i < argc; i++) {
			json_array_add_string(a,argv[i]);
		}
#if 0
//			dprintf(1,"adding: %s\n", argv[i]);
			conv_type(DATA_TYPE_LIST,&lp,0,DATA_TYPE_STRING,argv[i],strlen(argv[i]));
			list_reset(lp);
			while((p = list_get_next(lp)) !=0) {
				dprintf(1,"adding to array: %s\n", p);
				json_array_add_string(a,p);
			}
			list_destroy(lp);
		}
#endif
	} else if (act == 2) {
		json_object_t *o;
		char *label;
		int next;

		next = 0;
		o = json_create_object();
		for(i=2; i < argc; i++) {
			if (next) {
				dprintf(1,"adding: %s:%s\n",label,argv[1]);
				json_object_set_string(o,label,argv[i]);
				json_array_add_object(a,o);
				next = 0;
			} else {
				label = argv[i];
				next = 1;
			}
		}
		if (next) {
			log_warning("%s: no value provided, ignoring\n",label);
		}
	}

#endif
}

#define NAME_FORMAT "%-20.20s  "
#define TYPE_FORMAT "%-10.10s  "
#define SCOPE_FORMAT "%-10.10s  "
#define VALUE_FORMAT "%s  "
#define LABEL_FORMAT "%s"
#define UNITS_FORMAT " >%s<"

static int do_list_item(char *target, int level, json_object_t *o, int hdr) {
	json_array_t *labels;
	char *name,*dtype,*scope;
	char pad[16],line[1024],*p,*units;
	int i,j,type;

	dprintf(1,"target: %s, level: %d, obj: %p, hdr: %d\n", target, level, o, hdr);

	pad[0] = 0;
	for(i=0; i < level; i++) strcat(pad,"  ");

	if (hdr) printf("%s"NAME_FORMAT""TYPE_FORMAT""SCOPE_FORMAT""VALUE_FORMAT""LABEL_FORMAT""UNITS_FORMAT"\n",pad,"Name","Type","Scope","Values","(Labels)","Units");
	name = json_object_get_string(o,"name");
	dprintf(1,"name: %s\n", name);
	dtype = json_object_get_string(o,"type");
	dprintf(1,"dtype: %p\n", dtype);
#if 0
//	dprintf(1,"o->count: %d\n", o->count);
	for(i=0; i < o->count; i++) {
		name = o->names[i];
		dprintf(1,"[%d]: name: %s, type: %s\n", i, name, json_typestr(json_value_get_type(o->values[i])));
		if (json_value_get_type(o->values[i]) != JSON_TYPE_OBJECT) continue;
		oo = json_value_get_object(o->values[i]);
#endif
		dtype = json_object_get_string(o,"type");
		dprintf(1,"dtype: %p\n", dtype);
		if (!dtype) return 1;
		dprintf(1,"dtype: %s\n", dtype);
		p = line;
		p += sprintf(p,"%s"NAME_FORMAT""TYPE_FORMAT,pad,name,dtype);
		scope = json_object_get_string(o,"scope");
		if (scope) { 
			dprintf(1,"scope: %s\n", scope);
			p += sprintf(p,SCOPE_FORMAT,scope);
			if (strcmp(scope,"select")==0) {
				json_array_t *values;
				float num;
				int inum;

				values = json_object_get_array(o,"values");
				dprintf(1,"values: %p\n", values);
				if (values) {
					for(j=0; j < values->count; j++) {
						if (j) p += sprintf(p,",");
						type = json_value_get_type(values->items[j]);
						dprintf(1,"type: %d\n", type);
						switch(type) {
						case JSON_TYPE_STRING:
							p += sprintf(p,"%s",json_value_get_string(values->items[j]));
							break;
						case JSON_TYPE_NUMBER:
							num = json_value_get_number(values->items[j]);
							inum = num;
							if (inum == num) p += sprintf(p,"%d",inum);
							else p += sprintf(p,"%f",num);
							break;
						default:
							p += sprintf(p,"unhandled type: %d",type);
							break;
						}
					}
				}
			} else if (strcmp(scope,"range")==0) {
				json_array_t *values;
				double min,max,step;
				int imin,imax,istep;

				/* values array should have 3 items */
				values = json_object_get_array(o,"values");
				dprintf(1,"values: %p\n", values);
				if (!values) {
					printf("  %s: invalid info format(range specified but no values\n",name);
					return 1;
				}
				if (values->count != 3) {
					printf("  %s: invalid info format(range specified but values count != 3\n",name);
					return 1;
				}
				min = json_value_get_number(values->items[0]);
#define DTEST(a,b) !((a>b)||(a<b))
				imin = min;
				if (imin == min || DTEST(min,0.0)) p += sprintf(p,"min: %d, ",imin);
				else p += sprintf(p,"min: %lf, ",min);
				max = json_value_get_number(values->items[1]);
				imax = max;
				if (imax == max || DTEST(max,0.0)) p += sprintf(p,"max: %d, ",imax);
				else p += sprintf(p,"max: %lf, ",max);
				step = json_value_get_number(values->items[2]);
				istep = step;
				if (istep == step || DTEST(step,0.0)) p += sprintf(p,"step: %d",istep);
				else p += sprintf(p,"step: %lf",step);
			}
			labels = json_object_get_array(o,"labels");
			dprintf(1,"labels: %p\n", labels);
			if (labels && labels->count) {
				p += sprintf(p," (");
				for(j=0; j < labels->count; j++) {
					if (j) p += sprintf(p,",");
					p += sprintf(p,"%s",json_value_get_string(labels->items[j]));
				}
				p += sprintf(p,")");
			}
			units = json_object_get_string(o,"units");
			if (units && strlen(units))  p += sprintf(p," >%s<", units);
		} else {
			p += sprintf(p,SCOPE_FORMAT,dtype);
			if (strcmp(dtype,"bol")==0) p += sprintf(p,"true/false");
		}
		printf("%s\n",line);
//	}
	return 0;
}

static int do_list_section(char *target, json_object_t *o) {
	json_array_t *a;
	int i,type;

	/* A section is a single object with array of items */
	printf("  %s\n", o->names[0]);
	dprintf(1,"target: %s, type: %s\n", target, json_typestr(json_value_get_type(o->values[0])));
	if (json_value_get_type(o->values[0]) != JSON_TYPE_ARRAY) return 1;
	a = json_value_get_array(o->values[0]);
	dprintf(1,"a->count: %d\n", a->count);
	for(i = 0; i < a->count; i++) {
		type = json_value_get_type(a->items[i]);
		dprintf(1,"item[%d]: type: %s\n", i, json_typestr(type));
		if (json_value_get_type(a->items[i]) != JSON_TYPE_OBJECT) continue;
		if (do_list_item(target,2,json_value_get_object(a->items[i]),i == 0)) return 1;
	}
	return 0;
}

void do_list(client_agent_info_t *ap) {
	json_object_t *o,*o2;
	json_array_t *a,*a2;
//	char target[SOLARD_ROLE_LEN+SOLARD_NAME_LEN];
	int i,j,k,sec,type;

	o = json_value_get_object(ap->info);
//	a = json_object_get_array(json_object(ap->info),"configuration");
	for(i=0; i < o->count; i++) {
		dprintf(1,"label[%d]: %s\n",i,o->names[i]);
		if (strcmp(o->names[i],"configuration")!=0) continue;
		/* Configuration is an array of objects */
		if (json_value_get_type(o->values[i]) != JSON_TYPE_ARRAY) {
			printf("  invalid info format(configuration section is not an array)\n");
			return;
		}
		/* Check array for sections */
		sec = 0;
		a = json_value_get_array(o->values[i]);
		dprintf(1,"a->count: %d\n", a->count);
		for(j=0; j < a->count; j++) {
			/* Better be an object */
			type = json_value_get_type(a->items[j]);
			dprintf(1,"[%d]: type: %d(%s)\n", j, type, json_typestr(type));
			if (type != JSON_TYPE_OBJECT) {
				printf("  invalid info format (configuration not array of objects)\n");
				return;
			}
			/* if this object has 1 entry and it's an array, it's a section */
			o2 = json_value_get_object(a->items[j]);
			type = json_value_get_type(o2->values[0]);
			dprintf(1,"o2->count: %d, type: %d(%s)\n", o2->count, type, json_typestr(type));
			if (o2->count == 1 && type == JSON_TYPE_ARRAY) {
				dprintf(1,"setting section flag...\n");
				sec = 1;
			}
		}
		/* If 1 entry is a section, they must all be sections */
		dprintf(1,"sec: %d\n", sec);
		if (sec) {
			for(j=0; j < a->count; j++) {
				o2 = json_value_get_object(a->items[j]);
				type = json_value_get_type(o2->values[0]);
				if (o2->count != 1 || type != JSON_TYPE_ARRAY) {
					printf("  invalid info format (mixed sections and non sections)\n");
					return;
				}
				/* All array values must be objects */
				a2 = json_value_get_array(o2->values[0]);
//				dprintf(1,"a2->count: %d\n", a2->count);
				for(k=0; k < a2->count; k++) {
					if (json_value_get_type(a2->items[k]) != JSON_TYPE_OBJECT) {
						printf("  invalid info format (configuration item not an object)\n");
						return;
					}
				}
			}
		}

		for(j=0; j < a->count; j++) {
			o2 = json_value_get_object(a->items[j]);
			if (sec) {
				do_list_section(ap->target,o2);
			} else {
				do_list_item(ap->target,1,o2,j==0);
			}
		}
	}
}

void parse_funcs(client_agent_info_t *ap) {
	json_object_t *o;
	json_array_t *a;
	config_function_t newfunc;
	char *p;
	int i;

	/* Functions is an array of objects */
	/* each object has name and args */
	a = json_object_get_array(json_value_get_object(ap->info), "functions");
	dprintf(1,"a: %p\n", a);
	if (!a) return;
	for(i=0; i < a->count; i++) {
		if (json_value_get_type(a->items[i]) != JSON_TYPE_OBJECT) continue;
		o = json_value_get_object(a->items[i]);
		p = json_object_get_string(o,"name");
		newfunc.name = malloc(strlen(p)+1);
		if (!newfunc.name) {
			log_syserror("parse_funcs: malloc(%d)",strlen(p)+1);
			exit(1);
		}
		strcpy(newfunc.name,p);
		newfunc.nargs = json_object_get_number(o,"nargs");
		dprintf(1,"adding: %s\n", newfunc.name);
		list_add(ap->funcs,&newfunc,sizeof(newfunc));
	}
}

config_function_t *get_func(client_agent_info_t *ap, char *name) {
	config_function_t *f;

	if (ap->funcs) {
		list_reset(ap->funcs);
		while((f = list_get_next(ap->funcs)) != 0) {
			if (strcmp(f->name,name)==0)
				return f;
		}
	}
	return 0;
}

int ping_agent(client_agent_info_t *ap) {
	return 0;
}

void usage() {
	printf("usage: sdconfig <target> <func> <item> [<value>]\n");
	exit(1);
}

int main(int argc,char **argv) {
	char message[8192];
	char topic[128],*p;
	char target[SOLARD_NAME_LEN];
	char func[SOLARD_FUNC_LEN];
	solard_client_t *s;
	solard_message_t *msg;
	int timeout,read_flag,list_flag,no_flag;
	opt_proctab_t opts[] = {
                /* Spec, dest, type len, reqd, default val, have */
		{ "-t:#|wait time",&timeout,DATA_TYPE_INT,0,0,"10" },
		{ "-r|ignore persistant config",&read_flag,DATA_TYPE_BOOL,0,0,"0" },
		{ "-n|do not ping agent",&no_flag,DATA_TYPE_BOOL,0,0,"0" },
		{ "-l|list parameters",&list_flag,DATA_TYPE_BOOL,0,0,"0" },
		{ ":target|agent name",&target,DATA_TYPE_STRING,sizeof(target)-1,1,0 },
		{ ":func|agent func",&func,DATA_TYPE_STRING,sizeof(func)-1,0,0 },
		OPTS_END
	};
	list agents;
	json_value_t *v;
	client_agent_info_t newagent,*ap;
	time_t start,now;
	config_function_t *f;
#if TESTING
	char *args[] = { "sdconfig", "-d", "6", "-l", "Battery/jbd" };
	argc = (sizeof(args)/sizeof(char *));
	argv = args;
#endif

	debug = 4;
	log_open("sd",0,0xffff);

	s = client_init(argc,argv,opts,"sdconfig");
	if (!s) return 1;

	dprintf(1,"target: %s, func: %s, %d\n", target, func);
	if (!strlen(func) && !list_flag) {
		log_error("either list flag or func must be specified\n");
		return 1;
	}

        argc -= optind;
        argv += optind;
        optind = 0;

	agents = list_create();
	if (!agents) {
		log_syserror("list_create");
		return 1;
	}

	if (!no_flag) {
	/* Send a "ping" request */
	dprintf(1,"sending ping...\n");
	sprintf(topic,"%s/%s/Ping",SOLARD_TOPIC_ROOT,target);
	mqtt_pub(s->m,topic,s->mqtt_config.clientid,1,0);

	/* Get the replie(s) */
	time(&start);
	while(1) {
		list_reset(s->mq);
		while((msg = list_get_next(s->mq)) != 0) {
			solard_message_dump(msg,1);
			dprintf(1,"id: %s, clientid: %s\n", msg->id,s->mqtt_config.clientid);
			if (strcmp(msg->id,s->mqtt_config.clientid)!=0) {
				list_delete(s->mq,msg);
				continue;
			}
			memset(&newagent,0,sizeof(newagent));
			ap = &newagent;
			ap->funcs = list_create();
			v = json_parse(msg->data);
			if (!v) {
				dprintf(1,"%s: not a valid json struct\n",msg->data);
				continue;
			}
			p = json_object_dotget_string(json_value_get_object(v),"Pong.ID");
			if (p) {
				strcpy(ap->id,p);
				p = json_object_dotget_string(json_value_get_object(v),"Pong.Target");
				if (p) strcpy(ap->target,p);
			}
			json_destroy_value(v);
			if (!strlen(ap->target)) continue;
			dprintf(1,"adding: id: %s, target: %s\n",ap->id,ap->target);
			list_add(agents,&newagent,sizeof(newagent));
			list_delete(s->mq,msg);
		}
		time(&now);
		if ((now - start) > 1)  break;
		sleep(1);
	}
	if (!list_count(agents)) {
		log_error("no agents responded\n");
		return 1;
	}
	} else {
		memset(&newagent,0,sizeof(newagent));
		ap = &newagent;
		ap->funcs = list_create();
		strncpy(ap->target,target,sizeof(ap->target)-1);
		list_add(agents,&newagent,sizeof(newagent));
	}

	/* For each agent, get the info */
	list_reset(agents);
	while((ap = list_get_next(agents)) != 0) {
		/* Sub to topic */
		sprintf(topic,"%s/%s/%s",SOLARD_TOPIC_ROOT,ap->target,SOLARD_FUNC_INFO);
		if (mqtt_sub(s->m,topic)) return 0;

		while(!ap->info) {
			/* Ingest info */
			dprintf(1,"waiting for info from: %s\n", ap->target);
			msg = solard_message_wait_target(s->mq, ap->target, 5);
			if (!msg) {
				config_function_t gi = { "get_info", 0, 0, 0 };

				/* Call the get info function */
				v = catargs(0,0,&gi);
				json_tostring(v,message,sizeof(message)-1,1);
				if (agent_request(s,ap,message,5)) break;
				json_destroy_value(v);
			} else {
				/* parse the info */
				ap->info = json_parse(msg->data);
				if (ap->info) {
					if (json_value_get_type(ap->info) != JSON_TYPE_OBJECT) {
						log_error("invalid info data from: %s\n", ap->target);
						break;
					}
					/* Parse the funcs */
					parse_funcs(ap);
				} else {
					log_error("unable to parse info from: %s\n", ap->target);
					break;
				}
			}
			list_delete(s->mq, msg);
		}
	}

	if (list_flag) {
		list_reset(agents);
		while((ap = list_get_next(agents)) != 0) do_list(ap);
		return 0;
	}

	/* For each agent ... */
	list_reset(agents);
	while((ap = list_get_next(agents)) != 0) {
		printf("====> id: %s\n", ap->id);
		if (!strlen(ap->id)) return 1;
		f = get_func(ap,func);
		if (!f) {
			log_error("target %s does not support function %s\n", ap->target, func);
			continue;
		}
		dprintf(1,"argc: %d, nargs: %d\n", argc, f->nargs);
		/* Args must be divisible by nargs */
		if (!f->nargs && argc) {
			log_warning("function %s/%s takes %d arguments but %d given, arguments ignored\n",
				ap->target, f->name, f->nargs, argc);
		} else if (f->nargs && (argc % f->nargs) != 0) {
			log_error("insufficient arguments: function %s/%s requires %d arguments but %d given\n",
				ap->target, f->name, f->nargs, argc);
			continue;
		}

		v = catargs(argc,argv,f);
		json_tostring(v,message,sizeof(message)-1,1);
		if (agent_request(s,ap,message,10)) continue;
		json_destroy_value(v);
	}

	return 0;

#if 0
		/* Sub to the target(s) ID and config */
		list_reset(agents);
		while((ap = list_get_next(agents)) != 0) {
			sprintf(topic,"%s/%s",SOLARD_TOPIC_ROOT,ap->id);
			dprintf(1,"topic: %s\n", topic);
			if (mqtt_sub(s->m,topic)) return 0;
			sprintf(topic,"%s/%s/%s/+",SOLARD_TOPIC_ROOT,ap->target,SOLARD_FUNC_CONFIG);
			dprintf(1,"topic: %s\n", topic);
			if (mqtt_sub(s->m,topic)) return 0;
		}
		/* Ingest the configs */
		solard_message_wait(s->mq, 3);
	}

	dprintf(1,"count: %d\n", list_count(s->mq));
	list_reset(s->mq);
	while((msg = list_get_next(s->mq)) != 0) {
		dprintf(1,"msg->replyto: %p\n",msg->replyto);
		dprintf(1,"Got response:\n");
		solard_message_dump(msg,1);
		v = json_parse(msg->data);
		dprintf(1,"v: %p\n", v);
	}
#endif

	return 0;
#if 0
	v = catargs(action,argc,argv);
	if (!v) return 1;
	json_dumps_r(v,message,sizeof(message)-1);
	dprintf(1,"message: %s\n", message);
	list_reset(agents);
	if (strcmp(action,"Add") == 0) timeout += 30;
	while((ap = list_get_next(agents)) != 0) {
		_doconfig2(s,message,ap,timeout,read_flag);
	}
	json_destroy_value(v);
#endif

#if 0
	{
		json_value_t *v,*a;
		list l;

		len = 0;
		for(i=2; i < argc; i++) len += strlen(argv[i])+1;
		/* Alloc a string to hold */
		temp = malloc(len+1);
		if (!temp) {
			log_write(LOG_SYSERR,"malloc temp(%d)",len+1);
			return 1;
		}
		p = temp;
		for(i=2; i < argc; i++) p += sprintf(p,"%s ",argv[i]);
		dprintf(1,"temp: %s\n", temp);
		conv_type(DATA_TYPE_LIST,&l,0,DATA_TYPE_STRING,temp,strlen(temp));
		free(temp);

	v = json_create_object();
	a = json_create_array();
	list_reset(l);
	while((p = list_get_next(l)) != 0) json_array_add_string(a,p);
	json_object_set_array(v,action,a);
	json_dumps_r(v,message,sizeof(message)-1);
	dprintf(1,"message: %s\n", message);
	list_reset(agents);
	while((infop = list_get_next(agents)) != 0) {
		_doconfig2(s,message,infop->id,timeout,read_flag);
	}
	json_destroy(v);
	}
#endif
	return 0;

#if 0
	/* Get/Set/Add/Del */
	dprintf(1,"action: %s\n", action);
	if (strcasecmp(action,"get") == 0 || strcasecmp(action,"read") == 0) {
		/* All args are items to get */
		v = catargs("Get",argc,argv);
		json_tostring(v,message,sizeof(message)-1,0);
	} else if (strcasecmp(action,"del") == 0 || strcasecmp(action,"delete") == 0 || strcasecmp(action,"remove") == 0) {
		/* All args are items to delete */
		v = catargs("Del",argc,argv);
		json_tostring(v,message,sizeof(message)-1,0);
	} else if (strcasecmp(action,"set") == 0 || strcasecmp(action,"write") == 0) {
		/* All args are label/value pairs with equal sign */
		/* Compile all arguments into a single string */
		/* Get the length */
		len = 0;
		for(i=2; i < argc; i++) len += strlen(argv[i])+1;
		/* Alloc a string to hold */
		temp = malloc(len+1);
		if (!temp) {
			log_write(LOG_SYSERR,"malloc temp(%d)",len+1);
			return 1;
		}
		p = temp;
		for(i=2; i < argc; i++) p += sprintf(p,"%s ",argv[i]);
		dprintf(1,"temp: %s\n", temp);
		strncpy(message,temp,sizeof(message)-1);
		free(temp);
	}
	dprintf(1,"message: %s\n", message);
	_doconfig2(s,message,target,timeout,read_flag);
	exit(0);

#if 0
	conv_type(DATA_TYPE_LIST,&lp,0,DATA_TYPE_STRING,temp,len);
	count = list_count(lp);
	dprintf(1,"count: %d\n", count);
	if (!count) return usage(1);
#endif

	if (strcasecmp(action,"get") == 0 || strcasecmp(action,"del") == 0) {
		/* get/del: single param, no = sign */
		if (count == 1) {
			if (strcasecmp(action,"get")==0) {
				_doconfig(s,lp,"Get",target,timeout,read_flag);
			} else if (strcasecmp(action,"del")==0) {
				_doconfig(s,lp,"Del",target,timeout,read_flag);
			}
#if 0
		} else {
			char **names;
			list values;

			names = malloc(count*sizeof(char *));
			i = 0;
			list_reset(lp);
			while((p = list_get_next(lp)) != 0) names[i++] = p;
			dprintf(1,"action: %s\n", action);
			if (strcasecmp(action,"get")==0) {
				values = client_get_mconfig(s,"Get",target,count,names,30);
				if (!values) return 1;
				i = 0;
				list_reset(values);
				while((val = list_get_next(values)) != 0) {
					printf("%s %s\n", names[i++], val);
				}
#if 0
			} else if (strcasecmp(action,"del")==0) {
				if (client_del_mconfig(s,count,names,30)) {
					printf("error deleting items\n");
					return 1;
				}
#endif
			}
#endif
		}
#if 0
	} else if (strcasecmp(action,"set")==0) {
		client_set_config(s,"Set",target,argv[2],argv[3],15);
#endif
	} else if (strcasecmp(action,"add")==0) {
//		client_set_config(s,"Add",target,argv[2],argv[3],30);
		_doconfig(s,lp,"Add",target,timeout,read_flag);
	} else {
		log_write(LOG_ERROR,"invalid action: %s\n", action);
		return 1;
	}

	free(s);
#endif
	return 0;
}
